$schema: 'https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json'
name: daScript
scopeName: source.dascript
patterns:
  - include: '#comments'
  - include: '#annotations'
  - include: '#struct_declaration'
  - include: '#function'
  - include: '#keywords'
  - include: '#strings'
  - include: '#builtin_types'
  - include: '#builtin_functions_name'
  - include: '#builtin_functions_call'
  - include: '#function_call'
  - include: '#function_no_args'
  - include: '#variable_declaration'
  - include: '#options_specifier'
  - include: '#require_specifier'
  - include: '#module_specifier'
  - include: '#assignment'
  - include: '#typedef'
  - include: '#template'
  - include: '#identifier'
repository:
  literals:
    patterns:
      - match: \b(true|false|null)\b
        name: constant.language.dascript
      - match: \b(?i:(0x\h+)L)
        name: constant.numeric.integer.hexadecimal.long.dascript
      - match: \b(?i:(0x\h+))
        name: constant.numeric.integer.hexadecimal.dascript
      - match: \b(?i:(0b[01]+)L)
        name: constant.numeric.integer.binary.long.dascript
      - match: \b(?i:(0b[01]+))
        name: constant.numeric.integer.binary.dascript
      - match: \b(?i:(0[o]?[0-7]+)L)
        name: constant.numeric.integer.octal.long.dascript
      - match: \b(?i:(0[o]?[0-7]+)u)
        name: constant.numeric.integer.octal.ulong.dascript
      - match: \b(?i:(0[o]?[0-7]+))
        name: constant.numeric.integer.octal.dascript
      - match: \b(?i:(((\d+(\.(?=[^[:alpha:]_])\d*)?|(?<=[^[:alnum:]_])\.\d+)(e[\-\+]?\d+)?))J)
        name: constant.numeric.complex.dascript
      - match: \b(?i:(\d+\.\d*(e[\-\+]?\d+)?)F?)(?=[^[:alpha:]_])
        name: constant.numeric.float.1.dascript
      - match: (?<=[^[:alnum:]_])(?i:(\.\d+(e[\-\+]?\d+)?)F?)
        name: constant.numeric.float.3.dascript
      - match: \b(?i:(\d+e[\-\+]?\d+))
        name: constant.numeric.float.4.dascript
      - match: \b(?i:([1-9]+[0-9]*|0)F)
        name: constant.numeric.float.5.dascript
      - match: \b(\d+[ui]8)
        name: constant.numeric.integer.unsigned.dascript
      - match: \b(?i:([1-9]+[0-9]*|0)L)
        name: constant.numeric.integer.decimal.long.dascript
      - match: \b([1-9]+[0-9]*|0)
        name: constant.numeric.integer.decimal.dascript
  keywords:
    patterns:
      - match: \b(while|if|static_if|else|for|uninitialized|recover|in|is|as|elif|static_elif|return|break|try|expect|operator|finally|deref|with|cast|upcast|addr|continue|where|pass|label|goto|implicit|explicit|unsafe|aka|sealed|yield|operator)\b
        name: keyword.control.dascript
      - match: \b(default)\b
        name: storage.modifier.specifier.init.dascript
      - match: \b(type|typename|typeinfo)\b
        name: storage.modifier.specifier.init.dascript
      - match: \b(var|let|assume)\b
        name: storage.modifier.specifier.decl.dascript
      - match: \b(inscope|static|shared|public|private|override)\b
        name: storage.modifier.specifier.decl.attr.dascript
      - match: \b(new|delete)\b
        name: storage.modifier.specifier.alloc.dascript
      - match: \b(reinterpret|upcast|cast)\b
        name: storage.modifier.specifier.cast.dascript
      - match: \b(const)\b
        name: storage.modifier.specifier.const.dascript
      - match: \b(struct|class)\b
        name: storage.modifier.specifier.const.dascript
      - match: \b(iterator|array|fixed_array|table|smart_ptr|generator|tuple|table|variant|lambda|block|function)\b
        name: keyword.type.dascript
      - name: storage.modifier.function.dascript
        match: \$|\@
      - name: storage.modifier.capture.dascript
        match: \b(capture)\b
      - name: keyword.operator.dascript
        match: '%|\*|/|-|\+'
      - name: keyword.operator.dascript
        match: \.|\?\.|\?\?
      - name: keyword.operator.dascript
        match: <\||\|>
      - name: keyword.operator.dascript
        match: \&|!|\|
      - name: keyword.operator.assignment.dascript
        match: (=|:=|<-)
      - name: keyword.operator.increment.dascript
        match: \+\+
      - include: '#literals'
  strings:
    patterns:
      - name: string.quoted.double.dascript
        begin: ((?<!(?<!\\)\\)")
        end: ((?<!(?<!\\)\\)")
        patterns:
          - begin: ((?<!\\)\{)
            beginCaptures:
              '0': {name: punctuation.definition.block.begin.dascript}
            end: ((?<!\\)\})
            endCaptures:
              '0': {name: punctuation.definition.block.end.dascript}
            patterns:
              - include: $self
      - name: constant.character.escape.dascript
        match: \\.
      - name: string.quoted.single.dascript
        begin: "'"
        end: "'"
        patterns:
          - name: constant.character.escape.dascript
            match: \\.
      - name: string.quoted.other.dascript
        begin: '@"'
        end: '"'
        patterns:
          - name: constant.character.escape.dascript
            match: \\.
  comments:
    patterns:
      - name: comment.line.double-slash
        begin: (\/\/)
        end: (?=\n)
        patterns:
          - match: (\\)\n
      - name: comment.block
        begin: (\/\*)
        end: (\*\/)
  keyword_arguments:
    begin: \b([[:alpha:]_][[:alnum:]_]*)\s*(=)(?!=)
    beginCaptures:
      1: {name: variable.parameter.function.keyword.dascript}
      2: {name: keyword.operator.assignment.dascript}
    end: \s*(?:(,)|(?=[\)\:]))
    endCaptures:
      1: {name: punctuation.separator.parameters.dascript}
    patterns:
      - include: $self
  builtin_types:
    patterns:
      - name: support.type.dascript # all basic types from ds_parser.ypp
        match:
          (?x)
          (?<!\.)
          \b(
            bool | void | string | int | int2 | int3 | int4 |
            uint | uint2 | uint3 | uint4 | float | float2 |
            float3 | float4 | range | urange | int64 | uint64 |
            double | int8 | uint8 | int16 | uint16)
          \b(?!(\s*\())
      - name: support.type.auto.dascript
        match: \b(auto)\b
        captures:
          1: {name: keyword.type.dascript}
  builtin_functions_name:
    name: support.function.builtin.name.dascript # builtin functions from module_builtin_runtime.cpp
    match:
      (?x)
      (?<!\.|@)\b(
        deref | addr |
        panic | print | terminate | stackwalk | breakpoint |
        assert | verify | static_assert | concept_assert | debug | memzero | invoke |
        push | emplace | resize | erase | clear | capacity | key_exists | find)
      \b\s*(?!(\())
  builtin_functions_call:
    name: meta.function-call.builtin.dascript
    begin:
      (?x)
      (?<!\.)\b(
        deref | addr |
        panic | print | terminate | stackwalk | breakpoint |
        assert | verify | static_assert | concept_assert | debug | memzero | invoke |
        push | emplace | resize | erase | length | clear | capacity | key_exists | find)
      \b\s*(?=\()
    beginCaptures:
      1: {name: support.function.builtin.call.dascript}
    end: (\))
    endCaptures:
      1: {name: punctuation.definition.arguments.end.dascript}
    patterns:
      - begin: (\()
        beginCaptures:
          1: {name: punctuation.definition.arguments.begin.dascript}
        end: (?=\))
        patterns:
            - match: \b([[:alpha:]_][[:alnum:]_]*)(?=\s*[,)=\[])
              name: variable.parameter.function.argument.dascript
            - include: '#strings'
            - include: $self
  function_call:
    patterns:
      - name: meta.function-call.dascript 
        begin: (?:\.)?([[:alpha:]_][[:alnum:]_\:]*)\s*(?=(\())
        beginCaptures:
          1: {name: entity.name.function}
        end: (\))
        endCaptures:
          1: {name: punctuation.definition.arguments.end.dascript}
        patterns:
          - begin: (\()
            beginCaptures:
              1: {name: punctuation.definition.arguments.begin.dascript}
            end: (?=\))
            patterns:
                - match: \b([[:alpha:]_][[:alnum:]_]*)(?=\s*[,)=\[])
                  name: variable.parameter.function.argument.dascript
                - include: '#strings'
                - include: $self
      - name: meta.function-call.piped.dascript 
        begin: (?:\|\>)\s*([[:alnum:]_]+)\s*
        beginCaptures:
          1: {name: entity.name.function}
        end: (?:\<\|)
  function:
    name: meta.function.dascript
    begin: (def)\s+((?:private|public|abstract|override|static)\s+)?((?:private|public|abstract|override)\s+)?(operator)?(?=.+\s*\()|(\$)\s*(?=\[(?:.*?)\])|(\$)\s*(?=\()
    beginCaptures:
      1:
        name: storage.type.function.dascript
      2:
        name: keyword.type.dascript
      3:
        name: keyword.type.dascript
      4:
        name: keyword.type.dascript
      5:
        name: storage.type.function.dascript
      6:
        name: storage.type.function.dascript
      7:
        name: storage.type.function.dascript
    end: \(
    endCaptures:
      1:
        name: punctuation.section.function.begin.dascript
      2:
        name: entity.name.type.function.dascript
    contentName: entity.name.function.dascript
  arrays:
    patterns:
      - name: meta.array.dascript
        begin: \[
        beginCaptures:
          0: {name: punctuation.definition.array.begin.dascript}
        end: \]
        endCaptures:
          0: {name: punctuation.definition.array.end.dascript}
        patterns:
          - match: \"
            name: string.quoted.double.dascript
            begin: \"
            beginCaptures:
              0: {name: punctuation.definition.string.begin.dascript}
            end: \"
            endCaptures:
              0: {name: punctuation.definition.string.end.dascript}
            patterns:
              - include: '#escaped_char'
          - match: \w+
            name: variable.parameter.array.dascript
          - match: \d+
            name: constant.numeric.dascript
          - match: \+
            name: keyword.operator.arithmetic.dascript
          - match: \,
            name: punctuation.separator.array.dascript
          - match: \b(sin|cos|tan|log|exp|sqrt)\b
            name: support.function.math.dascript
          - match: \[
            name: punctuation.definition.array.begin.dascript
            push:
              - meta_scope: meta.array.inner.dascript
              - match: \]
                name: punctuation.definition.array.end.dascript
                pop: true
              - include: $self
          - match: \(
            name: punctuation.definition.arguments.begin.dascript
          - match: \)
            name: punctuation.definition.arguments.end.dascript
          - include: '#strings'
  function_no_args:
    name: meta.funciton.noargs.dascript
    begin: (def)\s+((?:private|public|abstract|override|static)\s+)?((?:private|public|abstract|override)\s+)?\s*(?:(operator\s*(.+?))|([[:alnum:]_]*))\s*(?!\()(?:\s*\:\s*([[:alnum:]_]+))?\s*(?=$|\{)
    beginCaptures:
      1:
        name: keyword.type.def.dascript
      2:
        name: keyword.type.modifier.dascript
      3:
        name: keyword.type.modifier.dascript
      4:
        name: keyword.type.operator.dascript
      5:
        name: entity.name.function.operator.dascript
      6:
        name: entity.name.function.dascript
      7:
        name: entity.name.type.function.return.dascript
    end: (?=$|\{)
  blocks:
    patterns:
      - name: meta.block.dascript
        begin: \{
        beginCaptures:
          0: {name: punctuation.definition.block.begin.dascript}
        end: \}
        endCaptures:
          0: {name: punctuation.definition.block.end.dascript}
        patterns:
          - include: $self
  annotations:
    patterns:
      - name: meta.declaration.annotation.dascript
        # Match '[' but not '[[' - (?: (?<!\[) \[ (?!\[) )
        begin: (((?<!\[|\<\-\s|\:\=\s|\=\s)\[(?!\[))\s*)(\()?
        beginCaptures:
          2: {name: punctuation.definition.annotation.dascript}
          3: {name: storage.type.annotation.dascript}
          4: {name: punctuation.definition.annotation-arguments.begin.bracket.round.dascript}
        end: (\))?(\])
        endCaptures:
          1: {name: punctuation.definition.annotation-arguments.end.bracket.round.dascript}
          2: {name: punctuation.definition.annotation.dascript}
        patterns:
          - include: '#function_call'
          - match: \b([[:alnum:]_]+)\b(?!\s*=\s*)
            name: storage.type.annotation.dascript
          - include: '#strings'
          - include: '#comments'
      - name: meta.declaration.annotation.gen2.dascript
        begin: ((?<!\@)\@[[:alnum:]_]+)
        beginCaptures:
          1: {name: support.function.annotation.dascript}
        end: (?=\=|\n|\s+)
        patterns:
          - include: '#comments'
  variable_declaration:
    name: meta.variable.declaration.dascript
    begin: (?<!\?.+?)(?:\:\s*)((?!auto|table|array|iterator|tuple|lambda|block))
    end: (?:\s*(\=|\s+|\n|\;))
    patterns:
      - include: '#literals'
      - include: '#template'
      - include: '#keywords'
      - match: ([[:alnum:]_]+)
        name: entity.name.type.dascript
  struct_declaration:
    patterns:
      - name: meta.class.dascript
        begin: (?x)\s*(struct|class|variant|tuple|enum|bitfield)\s*((?:private|public|sealed)*)?\s+(?=[[:alpha:]_]\w*\s*(:|\()?)
        beginCaptures:
          1: {name: keyword.type.dascript}
          2: {name: keyword.type.dascript}
        end: (?=\n)
        endCaptures:
          1: {name: punctuation.section.class.begin.dascript}
        patterns:
          - include: '#struct_name'
          - include: '#struct_inheritance'
          - include: '#comments'
  struct_name:
    name: entity.name.type.class.dascript
    match: (?x)\b([[:alpha:]_]\w*)\b
  struct_inheritance:
    name: meta.class.inheritance.dascript
    begin: (:)
    beginCaptures:
      1: {name: punctuation.definition.inheritance.begin.dascript}
    end: (?=\n)|(?=\s+)
    endCaptures:
      0: {name: punctuation.definition.inheritance.end.dascript}
    patterns:
      - match: (?x)\b([[:alpha:]_]\w*)\b
        captures:
          1: {name: entity.other.inherited-class.dascript}
  options_specifier:
    name: meta.options.dascript
    begin: \b(options)\s+([[:alnum:]_]+)\b((=)\b([[:alnum:]_]+))?
    beginCaptures:
      1: {name: keyword.control.dascript}
    end: (?=\n)
    patterns:
      - include: '#comments'
      - include: '#strings'
      - include: '#literals'
  require_specifier:
    name: meta.require.dascript
    begin: \b(require)\s+(.+?)\b
    beginCaptures:
      1: {name: keyword.control.dascript}
    end: (?=\s|\n|\;)
    patterns:
      - include: '#comments'
      - include: '#strings'
      - include: '#literals'
  module_specifier:
    name: meta.module.dascript
    begin: \b(module)\s*([[:alnum:]_]+)\s*(public|private|shared)?\s(public|private|shared)?
    beginCaptures:
      1: {name: keyword.module.dascript}
      2: {name: entity.name.type.module.dascript}
      3: {name: storage.modifier.module.dascript}
      4: {name: storage.modifier.module.dascript}
    end: (?=\n)
    patterns:
      - include: '#comments'
  assignment:
    name: meta.assignment.dascript
    begin: \b(?<!typedef\s*|\:\s*)([[:alpha:]_][[:alnum:]_]*)\s*(?=\=|\+\=|-\=|\*\=|\/\=|\&\=|\|\=|\^\=)
    beginCaptures:
      1: {name: variable.parameter.type.dascript}
    end: (?=\=|\+\=|-\=|\*\=|\/\=|\&\=|\|\=|\^\=)
    patterns:
      - include: '#comments'
  identifier:
    match: \b(?<!\:\s*)([[:alpha:]_][[:alnum:]_]*)\b
    name: variable.parameter.identifier.dascript
  typedef:
    name: meta.typedef.dascript
    begin: \b(typedef)\s*([[:alnum:]_]+)\b
    beginCaptures:
      1: {name: keyword.type.dascript}
      2: {name: entity.name.type.dascript}
    end: (?=\=)
  template:
    patterns:
      - name: meta.template.function.dascript
        begin: \b(?:(?<=block|lambda)\s*\<\s*)
        end: (?=\(|\>)
        patterns:
          - name: meta.template.function.short.dascript
            begin: (?=\<)
            patterns:
              1: {name: entity.name.type.dascript}
            end: (?=\>)
      - name: meta.template.dascript
        begin: \b\<(?!\<)(?=\s*[[:alnum:]_]+\s*)
        beginCaptures:
          1: {name: entity.name.type.dascript}
        end: \>
        patterns:
          - include: '#literals'
          - include: '#keywords'
          - name: meta.template.argument.variant.dascript
            begin: \b([[:alnum:]_]+)\s*\:\s*([[:alnum:]_]+)\b
            beginCaptures:
              1: {name: variable.parameter.variant.identifier.dascript}
              2: {name: entity.name.type.variant.argument.dascript}
            end: (?=\;|\>)
          - name: meta.template.argument.auto.dascript
            begin: \b(auto)\b
            beginCaptures:
              1: {name: storage.type.auto.dascript}
            end: (?=\)|\>)
            patterns:
              - name: entity.name.type.auto.typename.dscript
                match: \b([[:alnum:]_]+)\b
          - name: meta.template.argument.dascript
            begin: \b([[:alnum:]_]+)\b
            beginCaptures:
              1: {name: entity.name.type.dascript}
            end: (?=\;|\>)
            patterns:
              - include: '#keywords'