$schema: 'https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json'
name: daScript
scopeName: source.dascript
patterns:
  - include: '#comments'
  - include: '#annotations'
  - include: '#struct_declaration'
  - include: '#function'
  - include: '#keywords'
  - include: '#strings'
  - include: '#builtin_types'
  - include: '#builtin_functions_name'
  - include: '#builtin_functions_call'
  - include: '#function_call'
  - include: '#member_access'
  - include: '#variable_declaration'
  - include: '#options_specifier'
  - include: '#require_specifier'
  - include: '#module_specifier'
repository:
  literals:
    patterns:
      - match: \b(true|false)\b
        name: constant.language.dascript
      - match: \b(?i:(0x\h+)L)
        name: constant.numeric.integer.hexadecimal.long.dascript
      - match: \b(?i:(0x\h+))
        name: constant.numeric.integer.hexadecimal.dascript
      - match: \b(?i:(0b[01]+)L)
        name: constant.numeric.integer.binary.long.dascript
      - match: \b(?i:(0b[01]+))
        name: constant.numeric.integer.binary.dascript
      - match: \b(?i:(0[o]?[0-7]+)L)
        name: constant.numeric.integer.octal.long.dascript
      - match: \b(?i:(0[o]?[0-7]+)u)
        name: constant.numeric.integer.octal.ulong.dascript
      - match: \b(?i:(0[o]?[0-7]+))
        name: constant.numeric.integer.octal.dascript
      - match: \b(?i:(((\d+(\.(?=[^[:alpha:]_])\d*)?|(?<=[^[:alnum:]_])\.\d+)(e[\-\+]?\d+)?))J)
        name: constant.numeric.complex.dascript
      - match: \b(?i:(\d+\.\d*(e[\-\+]?\d+)?)F?)(?=[^[:alpha:]_])
        name: constant.numeric.float.dascript
      - match: \b(?i:(\d+(e[\-\+]?\d+)?)F?)(?=[^[:alpha:]_])
        name: constant.numeric.float.dascript
      - match: (?<=[^[:alnum:]_])(?i:(\.\d+(e[\-\+]?\d+)?)F?)
        name: constant.numeric.float.dascript
      - match: \b(?i:(\d+e[\-\+]?\d+))
        name: constant.numeric.float.dascript
      - match: \b(?i:([1-9]+[0-9]*|0)F)
        name: constant.numeric.float.dascript
      - match: \b(?i:([1-9]+[0-9]*|0)L)
        name: constant.numeric.integer.decimal.long.dascript
      - match: \b([1-9]+[0-9]*|0)
        name: constant.numeric.integer.decimal.dascript
  keywords:
    patterns:
      - match: \b(\$|struct|class|variant|def|while|if|static_if|else|for|recover|new|typeinfo|type|in|is|as|elif|static_elif|return|null|break|try|table|expect|const|operator|finally|delete|deref|typedef|with|cast|override|abstract|upcast|addr|continue|where|pass|reinterpret|public|label|goto|implicit|explicit|shared|private|unsafe|aka|assume|sealed|inscope|static|yield|operator)\b
        name: keyword.control.dascript
      - match: \b(const)\b
        name: storage.modifier.specifier.const.dascript
      - include: '#literals'
      - name: keyword.operator.dascript
        match: '%|\*|/|-|\+'
      - name: keyword.operator.dascript
        match: \.|\?\.|\?\?
      - name: keyword.operator.dascript
        match: <\||\|>
      - name: keyword.operator.dascript
        match: <|>|&|!|\|
      - name: keyword.operator.assignment.dascript
        match: (=|:=|<-)
      - name: keyword.operator.increment.dascript
        match: \+\+
  strings:
    patterns:
      - name: string.quoted.double.dascript
        begin: '"'
        end: '"'
        patterns:
        - name: constant.character.escape.dascript
          match: \\{
        - begin: (\{)
          beginCaptures:
            '0': {name: punctuation.definition.block.begin.dascript}
          end: (})
          endCaptures:
            '0': {name: punctuation.definition.block.end.dascript}
          patterns:
          - include: $self
          - include: '#identifiers'
        - name: constant.character.escape.dascript
          match: \\.
      - name: string.quoted.single.dascript
        begin: "'"
        end: "'"
        patterns:
          - name: constant.character.escape.dascript
            match: \\.
      - name: string.quoted.other.dascript
        begin: '@"'
        end: '"'
        patterns:
          - name: constant.character.escape.dascript
            match: \\.
  comments:
    patterns:
      - name: comment.line.double-slash
        begin: (\/\/)
        end: (?=\n)
        patterns:
          - match: (\\)\n
      - name: comment.block
        begin: (\/\*)
        end: (\*\/)
  identifiers:
    patterns:
    - include: '#parameter_name'
  parameter_name:
    match: '\b([_A-Za-z]\w*)\b'
    name: variable.parameter.dascript
  generic_names:
    name: meta.identifier.dascript
    match: '[[:alpha:]_][[:alnum:]_]*'
  dotted_name:
    begin: (?=(?:\.(?!\s+require)\s*)?[[:alpha:]_][[:alnum:]_]*(?:\s*\.\s*[[:alpha:]_][[:alnum:]_]*)*)
    end: (?![[:alnum:]_\.\s])|(?=(?<!\.)\s+[^.])|$
    patterns:
      - begin: (\.)(?=[[:alpha:]_][[:alnum:]_]*)
        beginCaptures:
          1: {name: meta.dot.dascript}
        end: (?![[:alnum:]_])
        patterns:
          - include: '#builtin_functions_name'
          - include: '#generic_names'
  keyword_arguments:
    begin: \b([[:alpha:]_][[:alnum:]_]*)\s*(=)(?!=)
    beginCaptures:
      1: {name: variable.parameter.function.keyword.dascript}
      2: {name: keyword.operator.assignment.dascript}
    end: \s*(?:(,)|(?=[\)\:]))
    endCaptures:
      1: {name: punctuation.separator.parameters.dascript}
    patterns:
      - include: $self
  builtin_types:
    patterns:
      - name: support.type.dascript # all basic types from ds_parser.ypp
        match:
          (?x)
          (?<!\.)
          \b(
            bool | void | string | auto | int | int2 | int3 | int4 |
            uint | bitfield | uint2 | uint3 | uint4 | float | float2 |
            float3 | float4 | range | urange | block | int64 | uint64 |
            double | function | lambda | int8 | uint8 | int16 | uint16)
          \b(?!(\s*\())
      - name: support.type.generic.dascript
        begin:
          (?x)
          (?<!\.)
          \b(array|tuple|generator|iterator|smart_ptr)
          \b(?=(\s*<)?|(\s*\())
        beginCaptures:
          1: {name: keyword.control.dascript}
          2: {name: keyword.operator.dascript}
        end: (>|\n|\;)\s*?
        endCaptures:
          1: {name: keyword.operator.dascript}
  builtin_functions_name:
    name: support.function.builtin.name.dascript # builtin functions from module_builtin_runtime.cpp
    match:
      (?x)
      (?<!\.|@)\b(
        deref | addr |
        panic | print | terminate | stackwalk | breakpoint |
        assert | verify | static_assert | concept_assert | debug | memzero | invoke |
        push | emplace | resize | erase | length | clear | capacity | key_exists | find)
      \b\s*(?!(\())
  builtin_functions_call:
    name: meta.function-call.builtin.dascript
    begin:
      (?x)
      (?<!\.)\b(
        deref | addr |
        panic | print | terminate | stackwalk | breakpoint |
        assert | verify | static_assert | concept_assert | debug | memzero | invoke |
        push | emplace | resize | erase | length | clear | capacity | key_exists | find)
      \b\s*(?=\()
    beginCaptures:
      1: {name: support.function.builtin.call.dascript}
    end: (\))
    endCaptures:
      1: {name: punctuation.definition.arguments.end.dascript}
    patterns:
      - begin: (\()
        beginCaptures:
          1: {name: punctuation.definition.arguments.begin.dascript}
        end: (?=\))
        patterns:
            - match: \b([[:alpha:]_][[:alnum:]_]*)(?=\s*[,)=\[])
              name: variable.parameter.function.argument.dascript
            - include: '#strings'
            - include: $self
  function_call:
    patterns:
      - name: meta.function-call.dascript 
        begin: (?:\.)?([[:alpha:]_][[:alnum:]_\:]*)\s*(?=(\())
        beginCaptures:
          1: {name: entity.name.function}
        end: (\))
        endCaptures:
          1: {name: punctuation.definition.arguments.end.dascript}
        patterns:
          - begin: (\()
            beginCaptures:
              1: {name: punctuation.definition.arguments.begin.dascript}
            end: (?=\))
            patterns:
                - match: \b([[:alpha:]_][[:alnum:]_]*)(?=\s*[,)=\[])
                  name: variable.parameter.function.argument.dascript
                - include: '#strings'
                - include: $self
      - name: meta.function-call.piped.dascript 
        begin: (?:\|\>)\s*([[:alnum:]_]+)\s*
        beginCaptures:
          1: {name: entity.name.function}
        end: (?:\<\|)
  annotated_arguments:
    begin: \b([[:alpha:]_][[:alnum:]_\,\ ]*)\s*(:)|(?=\()
    beginCaptures:
      1: {name: variable.parameter.function.dascript}
      2: {name: punctuation.separator.annotation.dascript}
    # Match ':' but not '::' - (?: (?<!:) : (?!:) )
    end: \s*(?:(;)|(?=$\n?|\)|(?:(?<!:):(?!:))))
    contentName: entity.name.type.dascript
    endCaptures:
      1: {name: punctuation.separator.parameters.dascript}
    patterns:
      - match: '='
        name: keyword.operator.assignment.dascript
      - match: \b(const)\b
        name: storage.modifier.specifier.const.dascript
      - include: $self
  function:
    name: meta.function.dascript
    begin: (def)\s+((?:private|public|abstract|override|static)\s+)?((?:private|public|abstract|override)\s+)?(operator)?(?=.+\s*\()|(\$)\s*(?=\[(?:.*?)\])|(\$)\s*(?=\()
    beginCaptures:
      1:
        name: storage.type.function.dascript
      2:
        name: keyword.type.dascript
      3:
        name: keyword.type.dascript
      4:
        name: keyword.type.dascript
      5:
        name: storage.type.function.dascript
      6:
        name: storage.type.function.dascript
      7:
        name: storage.type.function.dascript
    end: (\))(?:\s*\:\s*([[:alnum:]_]+))?
    endCaptures:
      1:
        name: punctuation.section.function.begin.dascript
      2:
        name: entity.name.type.function.dascript
    patterns:
      - include: '#annotations'
      - name: entity.name.function.dascript
        begin: (?=\w+)
        end: (?!\w)
      - contentName: meta.function.parameters.dascript
        begin: (\()
        beginCaptures:
          1: {name: punctuation.definition.parameters.begin.dascript}
        end: (?=\))
        patterns:
          - match: (\bvar\b)
            name: storage.modifier.specifier.var.dascript
          - include: '#annotated_arguments'
          - match: \b(?:([[:alpha:]_][[:alnum:]_]*))\s*(?:(;)|(?=[\n\)]))
            captures:
              1: {name: variable.parameter.function.dascript}
              2: {name: punctuation.separator.parameters.dascript}
      - begin: (\))
        beginCaptures:
          1: {name: punctuation.definition.parameters.end.dascript}
        end: (?=\))
        patterns:
          - include: $self
  arrays:
    patterns:
      - name: meta.array.dascript
        begin: \[
        beginCaptures:
          0: {name: punctuation.definition.array.begin.dascript}
        end: \]
        endCaptures:
          0: {name: punctuation.definition.array.end.dascript}
        patterns:
          - match: \"
            name: string.quoted.double.dascript
            begin: \"
            beginCaptures:
              0: {name: punctuation.definition.string.begin.dascript}
            end: \"
            endCaptures:
              0: {name: punctuation.definition.string.end.dascript}
            patterns:
              - include: '#escaped_char'
          - match: \w+
            name: variable.parameter.array.dascript
          - match: \d+
            name: constant.numeric.dascript
          - match: \+
            name: keyword.operator.arithmetic.dascript
          - match: \,
            name: punctuation.separator.array.dascript
          - match: \b(sin|cos|tan|log|exp|sqrt)\b
            name: support.function.math.dascript
          - match: \[
            name: punctuation.definition.array.begin.dascript
            push:
              - meta_scope: meta.array.inner.dascript
              - match: \]
                name: punctuation.definition.array.end.dascript
                pop: true
              - include: $self
          - match: \(
            name: punctuation.definition.arguments.begin.dascript
          - match: \)
            name: punctuation.definition.arguments.end.dascript
          - include: '#strings'
  blocks:
    patterns:
      - name: meta.block.dascript
        begin: \{
        beginCaptures:
          0: {name: punctuation.definition.block.begin.dascript}
        end: \}
        endCaptures:
          0: {name: punctuation.definition.block.end.dascript}
        patterns:
          - include: $self
  annotations:
    patterns:
      - name: meta.declaration.annotation.dascript
        # Match '[' but not '[[' - (?: (?<!\[) \[ (?!\[) )
        begin: (((?<!\[)\[(?!\[))\s*([[:alpha:]_][[:alnum:]_]+))\s*(\()?
        beginCaptures:
          2: {name: punctuation.definition.annotation.dascript}
          3: {name: storage.type.annotation.dascript}
          4: {name: punctuation.definition.annotation-arguments.begin.bracket.round.dascript}
        end: (\))?(\])
        endCaptures:
          1: {name: punctuation.definition.annotation-arguments.end.bracket.round.dascript}
          2: {name: punctuation.definition.annotation.dascript}
        patterns:
          - match: (\w*)\s*(=)
            captures:
              1: {name: variable.parameter.annotation.dascript}
              2: {name: keyword.operator.assignment.dascript}
          - include: '#strings'
  variable_declaration:
    patterns:
      - name: meta.variable.declaration.dascript
        begin: \b(var|let)\s*(inscope|private|public)?\s*(inscope|private|public)?\b
        end: (?=\s*?\=)|(?=\s*?\:)|(?=\s*\<)
        beginCaptures:
          1: {name: storage.modifier.specifier.dascript}
          2: {name: storage.modifier.specifier.dascript}
          3: {name: storage.modifier.specifier.dascript}
        endCaptures:
          0: {name: punctuation.section.variable.begin.dascript}
        patterns:
          - match: \b([[:alpha:]_][[:alnum:]_]*)\b
            name: variable.parameter.dascript
  struct_declaration:
    patterns:
      - name: meta.class.dascript
        begin: (?x)\s*(struct|class|variant|enum)\s*((?:private|public|sealed)*)?\s+(?=[[:alpha:]_]\w*\s*(:|\()?)
        beginCaptures:
          1: {name: keyword.type.dascript}
          2: {name: keyword.type.dascript}
        end: (?=\n)
        endCaptures:
          1: {name: punctuation.section.class.begin.dascript}
        patterns:
          - include: '#struct_name'
          - include: '#struct_inheritance'
          - include: '#comments'
  struct_name:
    name: entity.name.type.class.dascript
    match: (?x)\b([[:alpha:]_]\w*)\b
  struct_inheritance:
    name: meta.class.inheritance.dascript
    begin: (:)
    beginCaptures:
      1: {name: punctuation.definition.inheritance.begin.dascript}
    end: (?=\n)|(?=\s+)
    endCaptures:
      0: {name: punctuation.definition.inheritance.end.dascript}
    patterns:
      - match: (?x)\b([[:alpha:]_]\w*)\b
        captures:
          1: {name: entity.other.inherited-class.dascript}
  member_access:
    name: meta.member-access.dascript
    begin: \b([[:alnum:]_]+)(?:\.)([[:alnum:]_]+)\b
    beginCaptures:
      1: {name: variable.parameter.dascript}
      2: {name: variable.parameter.member-access.dascript}
    end: \b
  options_specifier:
    name: meta.options.dascript
    begin: \b(options)\s*([[:alnum:]_]+)\b((=)\b([[:alnum:]_]+))?
    beginCaptures:
      1: {name: keyword.control.dascript}
      2: {name: variable.type.other.require.dascript}
    end: (?=\n)
    patterns:
      - include: '#comments'
      - include: '#strings'
      - include: '#literals'
  require_specifier:
    name: meta.require.dascript
    begin: \b(require)\s*([[:alnum:]_\/]+)\b
    beginCaptures:
      1: {name: keyword.control.dascript}
      2: {name: variable.type.other.require.dascript}
    end: (?=\s*)
    patterns:
      - include: '#comments'
      - include: '#strings'
      - include: '#literals'
  module_specifier:
    name: meta.module.dascript
    begin: \b(module)\s*([[:alnum:]_]+)\s*(public|private|shared)?\s(public|private|shared)?
    beginCaptures:
      1: {name: keyword.type.module.dascript}
      2: {name: entity.name.type.module.dascript}
      3: {name: storage.modifier.module.dascript}
      4: {name: storage.modifier.module.dascript}
    end: (?=\n)
    patterns:
      - include: '#comments'